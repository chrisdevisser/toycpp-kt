package toycpp.dfa

import toycpp.encoding.MaxAsciiChar
import toycpp.encoding.MinAsciiChar
import toycpp.encoding.escapeAsciiStringForHumans
import toycpp.graph.depthCover

/**
 * Represents a unique ID given to nodes.
 */
private typealias Id = DfaNode.Id

/**
 * See [dfa]
 */
class DfaDsl<Output> {
    // The DFA DSL works in 3 steps:
    // 1. One section is designated as the start node. This begins a node DSL for it.
    // 2. Within a node DSL, transitions are described, leading to accepting nodes that emit a value.
    // 3. Once everything has been described, the entire DSL is built into a real DFA.
    //
    // One supported feature is using IDs in place of actual nodes. The corresponding nodes must then be created at some point in the future.
    // This hides the internal data apart from the provided API and allows for breaking node definitions out into later code instead of nesting them.
    // For the implementation, in-progress nodes are stored using NodeData, which has mutable members. These are mapped by ID in nodeDataById.
    // Because IDs can be used before their corresponding node is created, this storage cannot be assumed to have a node just because there's an ID for it.
    //
    // Each node can change after initially being built. This allows for things like `seq("abc") accepts Value.Foo` when the a, b, and c nodes already exist.
    // This makes the DSL flatter and allows organizing things more easily.
    internal data class NodeData<Output>(
        val id: Id,
        var acceptValue: Output?,
        val edges: MutableMap<Char, Id>
    ) {
        fun accept(value: Output) {
            acceptValue = value
        }

        /**
         * Compares two objects based only on their ID.
         */
        override fun equals(other: Any?): Boolean =
            other is NodeData<*> && id == other.id

        /**
         * Generates a hashcode based only on the ID.
         */
        override fun hashCode(): Int {
            return id.hashCode()
        }
    }

    /**
     * The start node of the DFA
     */
    private var start: Id? = null

    /**
     * Keeps track of all nodes created so far, accessed by their ID.
     */
    private val nodeDataById = mutableMapOf<Id, NodeData<Output>>()

    /**
     * A running counter used to generate unique IDs when no ID is given.
     */
    private var nextAutogenId = 0

    /**
     * Creates a new node with an autogenerated ID and designates it as the start node.
     *
     * There must be only one start node.
     */
    fun start(block: NodeDsl.() -> Unit) {
        check(start == null) { "Only one start node is allowed in a DFA DSL." }
        start = node("start", block)
    }

    /**
     * Creates a new node with the given ID and designates it as the start node.
     *
     * There must be only one start node.
     */
    fun start(id: String, block: NodeDsl.() -> Unit) {
        check(start == null) { "Only one start node is allowed in a DFA DSL." }
        start = node(id, block)
    }

    /**
     * Creates a new node with an autogenerated ID using a DSL.
     *
     * Matchers in the DSL are conceptually tried in lexical order.
     *
     * Example:
     *
     * ```
     * node {
     *     seq("Al") connects node("Starts with Al") {
     *         seq("ex") connects acceptingNode(Person)
     *         anythingSatisfying(isVowel) connects acceptingNode(AlVowels) // Ala, Ali, Alo, Alu
     *         anythingElse() connects acceptingNode(AlWord) // Al_ not covered above
     *     }
     * }
     * ```
     */
    fun node(block: NodeDsl.() -> Unit): Id =
        createNode(generateId(), acceptValue = null, block).id

    /**
     * Creates a new node with the given ID.
     *
     * @see [node]
     */
    fun node(id: String, block: NodeDsl.() -> Unit): Id =
        createNode(Id(id), acceptValue = null, block).id

    /**
     * Creates a new accepting node with an autogenerated ID.
     *
     * @see [node]
     */
    fun acceptingNode(value: Output, block: NodeDsl.() -> Unit = {}): Id =
        createNode(generateId(), value, block).id

    /**
     * Creates a new accepting node with the given ID.
     *
     * @see [node]
     */
    fun acceptingNode(id: String, value: Output, block: NodeDsl.() -> Unit = {}): Id =
        createNode(Id(id), value, block).id

    /**
     * Common implementation for creating new nodes.
     */
    private fun createNode(id: Id, acceptValue: Output?, block: NodeDsl.() -> Unit): NodeData<Output> {
        val nodeBuilder = NodeDsl(id, acceptValue)
        nodeBuilder.block()

        val node = nodeBuilder.toNodeData()
        return manageNode(node)
    }

    /**
     * Builds a proper DFA from the DSL.
     */
    internal fun build(): Dfa<Output> {
        requireNotNull(start) { "The DFA DSL must have a start node." }
        check(nodeDataById.values.any { it.acceptValue != null }) { "The DFA DSL must have at least one accepting node." }

//        return Dfa(start!!)
        // TODO
        return Dfa(DfaNode(Id(""), null, emptyList()))
    }

    /**
     * Keeps track of a node by its ID.
     *
     * A new node's ID must not match any existing IDs.
     */
    private fun manageNode(node: NodeData<Output>): NodeData<Output> {
        val existingNode = nodeDataById[node.id]
        check(existingNode == null || existingNode === node) { "Duplicate ID '${node.id}' added in DFA DSL." }

        nodeDataById += node.id to node
        return node
    }

    /**
     * Generates an ID that does not match any managed nodes.
     */
    private fun generateId(): Id {
        while (true) {
            val id = Id("auto:${nextAutogenId++}")
            if (id !in nodeDataById) return id
        }
    }

    /**
     * See [node]
     */
    inner class NodeDsl internal constructor(
        id: Id,
        acceptValue: Output? = null
    ) {
        /**
         * Refers to the node currently being built.
         */
        val selfId: Id = id

        /**
         * The actual node being built.
         */
        private val self: NodeData<Output> = NodeData(selfId, acceptValue, mutableMapOf())

        /**
         * A shortcut for the edges of the node being built.
         */
        private val edges = self.edges

        /**
         * Indicates that this is the accepting node.
         */
        fun accept(value: Output) {
            self.accept(value)
        }

        /**
         * Accepts any input that fulfills the given predicate. This predicate must be pure. It will be called immediately, not later.
         */
        fun anySatisfying(pred: (Char) -> Boolean) = AnySatisfyingPredicate(pred)

        /**
         * Accepts input that matches any of the given values.
         */
        fun any(options: String) = AnyMatchingCharacter(options)

        /**
         * Accepts a sequence of input, each matching the next value in the given values.
         *
         * The given sequence must not be empty.
         */
        fun seq(sequence: String) = Seq(sequence)

        /**
         * Repeats the given matcher the given number of times.
         */
        fun<Matcher> repeated(matcher: Matcher, times: Int) = Repeated(matcher, times)

        /**
         * Creates an edge that transitions to the node with the given ID for any input.
         *
         * There must exist at least one character that does not already have an associated edge.
         */
        fun anythingElse(): AnySatisfyingPredicate {
            val eligibleChars = (Char(0)..Char(127))
                .filter { it !in edges }

            require(eligibleChars.isNotEmpty()) { "There must exist at least one character that does not already have an associated edge. This is dead code. [ID='$selfId']" }

            return anySatisfying { true }
        }

        /**
         * Creates an edge that transitions to the node with the given ID if the input does not match any of the given values.
         *
         * There must exist at least one non-excluded character that does not already have an associated edge.
         */
        fun anyExcept(exclusions: String): AnySatisfyingPredicate {
            val eligibleChars = (MinAsciiChar..MaxAsciiChar)
                .filter {it !in exclusions }
                .filter { it !in edges }

            require(eligibleChars.isNotEmpty()) { "There must exist at least one non-excluded character that does not already have an associated edge. This is dead code. [ID='$selfId', exclusions='${escapeAsciiStringForHumans(exclusions)}]" }

            return anySatisfying { it !in exclusions }
        }

        /**
         * Creates an edge that transitions to the node with the given ID if the input matches the given value.
         *
         * The character must not already have an associated edge.
         */
        infix fun Char.connects(id: Id) {
            require(this !in edges) { "Attempted to add an edge for a character '${escapeAsciiStringForHumans(this.toString())}' that already has an edge. This would either be dead code or overwrite an edge. [ID='$selfId']" }
            edges += this to id
        }

        /**
         * Creates an edge that transitions to the node with the given ID if the input fulfills the given predicate.
         *
         * Only characters that do not already have an associated edge are eligible.
         * There must exist at least one eligible character.
         */
        infix fun AnySatisfyingPredicate.connects(id: Id) {
            val eligibleChars = (MinAsciiChar..MaxAsciiChar)
                .filter(pred)
                .filter { it !in edges }

            require(eligibleChars.isNotEmpty()) { "There must exist at least one character that satisfies the predicate and does not already have an associated edge. This is dead code. [ID='$selfId']" }

            for (c in eligibleChars) {
                edges += c to id
            }
        }

        /**
         * Creates an edge that transitions to the node with the given ID if the input matches any of the given values.
         *
         * All given characters must not have an existing edge.
         */
        infix fun AnyMatchingCharacter.connects(id: Id) {
            val charsWithEdge = options.filter { it in edges }
            require(charsWithEdge.isNotEmpty()) { "The following characters already have an existing edge: '${escapeAsciiStringForHumans(charsWithEdge)}' [ID='$selfId']" }

            for (c in options) {
                c connects id
            }
        }

        /**
         * Creates a series of nodes, the last of which transitions to the node with the given ID if each input matches the next value in the given sequence.
         *
         * Any nodes along the way that already exist are reused. These nodes must not be IDs that have not yet been created.
         * The final node must not already have an edge corresponding to the final character in the sequence.
         * The sequence must not be empty.
         */
        infix fun Seq.connects(id: Id) {
            require(seq.isNotEmpty()) { "The sequence must not be empty." }

            val nextToLastNode = getOrCreateNodeSequence(seq.dropLast(1))

            val lastChar = seq.last()
            require(lastChar !in nextToLastNode.edges) { "The next to last node (ID='${nextToLastNode.id}') in the sequence ${escapeAsciiStringForHumans(seq)} already has an edge corresponding to the final character in the sequence. [ID='$selfId']" }

            nextToLastNode.edges += lastChar to id
        }

        infix fun<Matcher> Repeated<Matcher>.connects(id: Id) {

        }

        /**
         * Marks the node reached via the given character as accepting with the given value.
         *
         * This node must not already be an accepting node.
         * If the node already has an ID, it must already be created.
         * Otherwise, if the node does not yet exist, it will be created.
         */
        infix fun Char.accepts(value: Output) {
            val node = getOrCreateNodeSequence(this.toString())
            require(node.acceptValue == null) { "The node (ID=${node.id}) corresponding to '${escapeAsciiStringForHumans(this.toString())}' is already an accepting node. [ID='$selfId']" }
            node.accept(value)
        }

        /**
         * Marks all nodes reached by characters that fulfill the given predicate as accepting with the given value.
         *
         * Only nodes that are not already accepting will change their accepting node state.
         * There must exist at least one non-accepting node.
         * If any of these nodes already has an ID, it must already be created.
         * Otherwise, if any node does not yet exist, it will be created.
         */
        infix fun AnySatisfyingPredicate.accepts(value: Output) {
            val nodes = (MinAsciiChar..MaxAsciiChar).map { getOrCreateNodeSequence(it.toString()) }

            val nonAcceptingNodes = nodes.filter { it.acceptValue == null }
            require(nonAcceptingNodes.isNotEmpty()) { "There must exist at least one non-accepting node that can be reached via the given predicate. This is dead code. [ID='$selfId']" }

            for (node in nodes) {
                node.accept(value)
            }
        }

        /**
         * Marks all nodes reached by the given characters as accepting with the given value.
         *
         * Each node must not already be accepting.
         * If any of these nodes already has an ID, it must already be created.
         * Otherwise, if any node does not yet exist, it will be created.
         */
        infix fun AnyMatchingCharacter.accepts(value: Output) {
            val nodes = options.map { getOrCreateNodeSequence(it.toString()) }

            val acceptingNodes = nodes.filter { it.acceptValue != null }
            require(acceptingNodes.isEmpty()) { "The nodes with the following IDs are already accepting nodes: ${acceptingNodes.joinToString { "'${it.id}'" }} [ID='$selfId']" }

            for (node in nodes) {
                node.accept(value)
            }
        }

        /**
         * Marks the node reached by the given sequence of characters as accepting with the given value.
         *
         * If this node or any node along the way already has an ID, it must already be created.
         * Otherwise, if any node does not yet exist, it will be created.
         */
        infix fun Seq.accepts(value: Output) {
            val node = getOrCreateNodeSequence(seq)
            require(node.acceptValue == null) { "The node (ID='${node.id}') corresponding to the sequence '${escapeAsciiStringForHumans(seq)}' is already accepting. [ID='$selfId']" }
            node.accept(value)
        }

        /**
         * Returns a new node that copies the node with the given ID and all nodes reachable from it at the time of the call.
         *
         * There must not be any cycles present.
         * The node corresponding to [startId] and all IDs reachable from it must have been created.
         */
        fun copyOf(startId: Id) {
            val start = nodeDataById[startId]
            requireNotNull(start) { "The start ID '$startId' does not have a created node." }

            val (nodes, cycleNodes) = depthCover(start, getNeighbors = {
                it.edges.values.map { neighborId ->
                    val neighbor = nodeDataById[neighborId]
                    requireNotNull(neighbor) { "The node with ID '$neighborId' was referenced, but has not yet been created." }
                    neighbor
                }
            })

            require(cycleNodes.isEmpty()) { "The nodes with the following IDs are involved in one or more cycles, but were used to create a copy: ${cycleNodes.joinToString { "'${it.id}'" }}" }

            fun newId(oldId: Id) = Id("$selfId: $oldId")

            for (node in nodes) {
                val copy = createNode(newId(node.id), node.acceptValue, {})
                copy.edges += node.edges.map { (k, id) -> k to newId(id) }
            }
        }

        /**
         * Converts the DSL into a proper interim node.
         */
        internal fun toNodeData(): NodeData<Output> = self

        /**
         * Traverses the interim DFA according to the given sequence of characters, creating nodes as needed.
         *
         * If any nodes along the way already has an ID, it must already be created.
         */
        private fun getOrCreateNodeSequence(seq: String): NodeData<Output> {
            var currentNode = self
            var charsSoFar = ""

            fun makeId(): String {
                val seqPiece = "'$charsSoFar'"
                return if (selfId == start) seqPiece else "$selfId + $seqPiece"
            }

            for (c in seq) {
                charsSoFar += c
                val nextId = currentNode.edges.getOrPut(c) { node(makeId()) {} }
                val nextNode = nodeDataById[nextId]
                checkNotNull(nextNode) { "The node with ID '$nextId' was referenced, but has not yet been created. [ID='$selfId']" }
                currentNode = nextNode
            }

            return currentNode
        }

        /**
         * See [anySatisfying]
         */
        inner class AnySatisfyingPredicate(val pred: (Char) -> Boolean)

        /**
         * See [any]
         */
        inner class AnyMatchingCharacter(val options: String)

        /**
         * See [seq]
         */
        inner class Seq(val seq: String)

        /**
         * See [repeated]
         */
        inner class Repeated<Matcher>(val matcher: Matcher, val times: Int)

    }
}

/**
 * Creates a DFA using a DSL.
 *
 * Example:
 * ```
 * val myDfa = dfa {
 *     start {
 *         // Nodes go here
 *     }
 * }
 * ```
 */
fun<Output> dfa(block: DfaDsl<Output>.() -> Unit): Dfa<Output> {
    val dfa = DfaDsl<Output>()
    block(dfa)
    return dfa.build()
}