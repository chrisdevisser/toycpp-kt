This document describes the design of components that are used throughout the entire compiler. Because these facilities are so fundamental, changing them later is potentially much more difficult than changing other components. As they have a large impact area, they are important to understand up front.

Location Tracking

Locations are attached to each character early on, resulting in a completely new type for the data. This approach keeps the location transparent. The important thing to remember is that this process is done lazily. Being lazy allows this code to be completely separate from the lexer. However, this generates one location per character and requires that the characters are not iterated through more than once so that their location counts only once for tracking purposes.

The other lazy option was to keep the location tracked and then generate a location on demand. However, this imposes an additional requirement that the current location matches the current point in the character sequence. In particular, this disables lookahead unless using a sequence with the necessary lookahead baked in, and this alters either the iterator or the element type of the sequence. This is relevant to line splices, which cannot determine just from a \ whether to include or discard it until more input is seen.

The classic non-lazy option is to have the lexer keep track of the location. Not only does this make it the lexer's responsibility to feed characters into the location tracking mechanism, but also pushes line splices to the lexer, disrupting the spec-based flow. However, this would remove the backlink in processing line splicing. In addition, it restores the on-demand nature of generating locations. This remains a viable alternative design.

#line must also be handled during preprocessing due to macro expansion being permitted within a #line directive. Location tracking is affected by #line directives. Unlike line splices, which do not carry the intent of changing locations, #line is a direct request, useful for matching generated code to the source location that produced it.

Because #line is handled so late conceptually, care must be taken to ensure errors later in the source reflect the changes. This is accomplished by lazily generating locations and lazily lexing so that preprocessing can happen while the file is still being lexed. In practice, each part from the end of encoding to the end of preprocessing is done all at once as each new character is processed. Once the end of a #line directive is reached, the piece of code responsible for tracking the location is forced to the given location. Upon processing the next character, the tracker will continue from its current state, which reflects the #line change.

In order to honour #line's request, source locations might be invalid. For example, they can be past the end of a file, in a non-existent file, or a location that has already been passed. For diagnostics, source locations must be checked before retrieving the appropriate source text.

Line splices are ignored for the purposes of location tracking because they would negatively affect the user experience. Picture getting a compiler error or failed assertion on line 831, but having the offending line of code be on line 850 in the editor. No benefit has been found to maintaining both physical and logical locations here.

Diagnostics

Each unique diagnostic has its own type that contains its severity and the relevant information. For example, a FileReadError contains the path of the file and a message explaining the cause. Each diagnostic type inherits from a common base class and provides necessary implementations. In this way, diagnostics are similar in design to exception classes and makes it easier to add new diagnostics than new diagnostic functionality. Currently, all diagnostics are contained in one place. However, this makes the diagnostics package dependent on types from other packages which are themselves dependent on diagnostics. In order to untangle this, the diagnostics can be changed from a closed hierarchy (a variant) to specific diagnostics being defined in their respective packages.

Diagnostics are a cross-cutting concern and treated as such. Rather than a diagnostic-related type being passed around to every piece of code that uses it (most code in the project), the diagnostic system is a singleton. Specifically, the system stores a sink that is invoked whenever a diagnostic is issued. In normal use, this sink reports the diagnostic to the user. To prevent forgetting a sink, one must be set before issuing diagnostics. To limit the impact of global state, it is expected that the sink does not change once set. However, it does make sense to reset the sink for each test run in a suite. Finally, the system keeps track of whether an error diagnostic is ever issued. This is expressly for the purpose of the program's return value and could be refactored into a sink if storing more than one sink is supported. Code is banned from reading this value otherwise.

Issuing a diagnostic is kept simple, inspired by Clang: `diag(DiagnosticType(information), relevantLocation)`. This gives the diagnostic to the set sink and continues. It is not allowed to affect any other code outside of tests, which capture diagnostics for later verification.